# Debugging Data

Your software consistently provides impressive music recommendations
by combining cultural and audio data. Customers are happy.
However, things aren't always perfect. Sometimes that Beyoncé track is
attributed to Beyonce. The artist for the Béla Fleck solo album shows up as
Béla Fleck and the Flecktones. Worse, the 宇多田ヒカル biography
has the artist name listed as ??????. Where did things go wrong?
Did one of your customers provide you with data in an incorrect
character encoding? Did one of the web-crawlers have a bug? Perhaps
the name resolution code was incorrectly combining a solo artist
with his band?

One of the most important tricks for dealing with
multi-provenance data is traceability and debuggability.
In this chapter, we'll explore ways of keeping track of
the source of our data, techniques for backing out
bad data, and the business value of adopting such
abilities.

## Why?

The ability to trace a datum back to its origin is important
for several reasons. It helps us to back-out or reprocess bad data,
and controversially, it allows us to reward and boost good data
sources and processing techniques.

////
qem 2012/07/04: also helps when local custom or even law requires
 you be able to track sources, such as California's "Shine The Light"
 law on data privacy.  I plan to mention this elsewhere in the book
 but it's also helpful/relevant here.
   http://www.leginfo.ca.gov/cgi-bin/displaycode?section=civ&group=01001-02000&file=1798.80-1798.84
   (Civil Code section 1798.83)]
////


## Software Analogy

In order to develop a repertoire for debugging data, we'll lean
heavily on debugging techniques borrowed from software development.
In particular, we'll take advantage of data immutability, a
technique popular in functional programming, that allows us to
model change, while still preserving a view toward the past.

### A Brief Functional Programming Tangent

In popular imperative languages, data tends to be mutable.
For example, if I want to sort a list, I might call
`myList.sort()`. This will sort the in-place. Consequently, all
references to `myList` will be changed. If we want to get a view
back to `myList` before it was sorted, we'd have to explicitly
make a copy. Functional languages, on the other hand, tend to treat
data immutably. Our list sorting example becomes something closer
to `myNewSortedList = sort(myList)`. This retains the unsorted
list `myList`.
