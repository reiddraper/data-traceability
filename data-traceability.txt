# Debugging Data

Your software consistently provides impressive music recommendations
by combining cultural and audio data. Customers are happy.
However, things aren't always perfect. Sometimes that Beyoncé track is
attributed to Beyonce. The artist for the Béla Fleck solo album shows up as
Béla Fleck and the Flecktones. Worse, the 宇多田ヒカル biography
has the artist name listed as ??????. Where did things go wrong?
Did one of your customers provide you with data in an incorrect
character encoding? Did one of the web-crawlers have a bug? Perhaps
the name resolution code was incorrectly combining a solo artist
with his band?

One of the most important tricks for dealing with
multi-provenance data is traceability and debuggability.
In this chapter, we'll explore ways of keeping track of
the source of our data, techniques for backing out
bad data, and the business value of adopting such
abilities.

## Why?

The ability to trace a datum back to its origin is important
for several reasons. It helps us to back-out or reprocess bad data,
and controversially, it allows us to reward and boost good data
sources and processing techniques. Furthermore, local privacy
laws can mandate things like auditability, data transfer
restrictions and more (TODO: citation).

////
qem 2012/07/04: also helps when local custom or even law requires
 you be able to track sources, such as California's "Shine The Light"
 law on data privacy.  I plan to mention this elsewhere in the book
 but it's also helpful/relevant here.
   http://www.leginfo.ca.gov/cgi-bin/displaycode?section=civ&group=01001-02000&file=1798.80-1798.84
   (Civil Code section 1798.83)]
////

We'll also see later how data traceability can provide further
business value by allowing us to provide stronger measurements
on the "worth" of a particular source, realize where to
focus our development effort, and even manage blame.

## Personal Experience

I previously worked as the data ingestion team lead at
a music data company. We provided artist and song recommendations,
artist biographies, news, and detailed audio analysis of digital
music. The data is exposed via a web service, along with
data dumps. Many of the data feeds are composed of many sources
of data which are cleaned, transformed, and put through
machine learning algorithms. One of the first issues we ran
into was learning how to trace a particular result back to its
constituent parts. If a particular artist recommendation
was poor, was it because of our machine learning algorithm?
Did we simply not have enough data for that artist? Was there
some obviously wrong data from one of our sources?

Over the course of few years we developed several mechanisms
for being able to debug our data woes. I'll explore several
specific examples here.

1. Snapshotting

Many of our data sources are updated frequently. Web pages,
for example, which we crawled for news, reviews, biography
information and similarity, are updated inconsistently,
and without notice. This means that even if we are able to trace
a particular datum back to a source, the source may be
drastically different than the time that we crawled or processed
the data. This meant that we needed to not only capture the
source of our data, but the time, and exact copy of the source.
Our database columns or keys would then have an extra field for
a timestamp. Keeping track of the time, and the original data
also allows you to track changes from that source. You get closer
to answering the question, "why were my recommendations for
The Sea and Cake great last week, but terrible today?".

## Software Analogy

In order to develop a repertoire for debugging data, we'll lean
heavily on debugging techniques borrowed from software development.
In particular, we'll take advantage of data immutability, a
technique popular in functional programming, that allows us to
model change, while still preserving a view toward the past.

### A Brief Functional Programming Tangent

In popular imperative languages, data tends to be mutable.
For example, if I want to sort a list, I might call
`myList.sort()`. This will sort the in-place. Consequently, all
references to `myList` will be changed. If we want to get a view
back to `myList` before it was sorted, we'd have to explicitly
make a copy. Functional languages, on the other hand, tend to treat
data immutably. Our list sorting example becomes something closer
to `myNewSortedList = sort(myList)`. This retains the unsorted
list `myList`.
